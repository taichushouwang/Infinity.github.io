title: 前端面试题
date: 2016-03-25 11:03:30
categories: 前端
tags: [前端]
description: 前端面试题
toc: true
---
##HTML/CSS
1. 什么是盒子模型？
  在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容(content)，元素的内边距(padding)，元素的边框(border)，元素的外边距(margin)四个部分。4个部分构成CSS的盒子模型。
  w3c标准：width = content;
  IE标准：width = border + padding + content;
2. 行内元素，块级元素，空元素
  行内元素: span、img、input、label、button、select、a、b、em、strong、textarea
  块级元素: dl、dt、dd、div、ul、li、p、h1-h6、blockquote
  空元素：br、meta、hr、link、input、img
3. CSS实现垂直水平居中
  http://blog.csdn.net/freshlover/article/details/11579669
  a.  .Center-Container {  position: relative;  }
		  .Absolute-Center {  width: 50%;  height: 50%;  overflow: auto;  margin: auto;  position: absolute;  top: 0; left: 0; bottom: 0; right: 0;  }
	b. 
4. href和src的区别
  href是指向网络资源所在位置，建立和当前元素或文档之间的链接，用于超链接
  src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时，会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素(img, iframe)也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。
5. CSS Hack
  概念：由于不同厂商的浏览器或浏览器的版本不同，对CSS的支持，解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，这个就叫CSS hack
  分类：CSS属性前缀（在属性前加"*/+/-/_"用于区别不同的浏览器），选择器前缀（在选择器前面加一些特殊符号）以及IE条件注释（<!--[if IE]>这段文字只在IE浏览器显示<![endif]-->）。实际上大多数都是为了IE而引入的。
6. 简述同步和异步的区别
  同步是阻塞模式，异步是非阻塞模式
  同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。
  异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。
7. px和em, rem的区别
  px, em和rem都是长度单位
  **px(pixel像素)** 绝对长度单位。像素px是相对于显示器屏幕分辨率而言的。
  所以px的值是固定的，在页面上指定是多少就是多少，计算比较容易。但是对不同显示设备不够灵活，效果不好。
  **em(emphasize)** 相对长度单位。相对于当前文本的字体尺寸。  em的值不是固定的，会继承父级元素的字体大小。
  比如
  ```html
  <div style="font-size: 12px">
    div的大小是16px
    <p style="font-size: 0.75em">
      这个p的大小是12*0.75=9px
      <p style="font-size: 2em">
        这个p的大小是9*2=18
      </p>
    </p>
  </div>
  ```

  所以em相对于px会灵活一些，在不同显示设备显示效果较好。但是计算起来会很麻烦。
  **rem(root em)** 相对长度单位。相对于根元素html的font-size的倍数，没有了继承父级尺寸这个关系。计算起来就很简便了。
8. 什么叫优雅降级和渐进增强
  渐进增强(progressive enhancement)：
　针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
　优雅降级(graceful degradation)：
　一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
　区别：
　　a.优雅降级是从复杂的现状开始，并试图减少用户体验的供给
　　b.渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要
　　c.降级(功能衰减)意味着往回看;而渐进增强则意味着朝前看，同时保证其根基处于安全地带
9. 浏览器的内核
  IE | trident内核
  Firefox | gecko内核
  Safari | webkit内核
  Chrome | 基于webkit的Blink
  Opera | Blink内核
  
10. [深入理解 CSS3 弹性盒布局模型](http://www.cnblogs.com/wyaocn/p/5813477.html)

##JavaScript
1. 创建节点
  `createDocumentFragment()`//创建一个DOM片段
  `createElement(nodename)`//创建一个具体的元素
  `createTextNode(text)`//创建一个文本节点
2. 添加、移除、替换、插入
  `appendChild(node对象)`//添加子节点
  `removeChild(node对象)`//移除并返回被删除的节点
  `replaceChild(newnode, oldnode)`//替换
  `insertBefore(newnode, existingnode)`//在子节点前插入新节点
3. 查找
  **注意！！！element后面到底有没有s!!!**
  getElementsByClassName()//通过类名获得元素
  getElementsByTagName()//通过标签名称
  getElementsByName()//通过元素的name属性的值
  getElementById()//通过元素id，唯一性
4. 实现一个函数clone, 可以对JavaScript中的5种主要的数据类型(包括Number、String、Object、Array、Boolen)进行值复制
  ```JavaScript
      /**
   * 对象克隆
   * 支持基本数据类型及对象
   * 递归方法
   */
  function clone(obj) {
      var o;
      switch (typeof obj) {
          case "undefined":
              break;
          case "string":
              o = obj + "";
              break;
          case "number":
              o = obj - 0;
              break;
          case "boolean":
              o = obj;
              break;
          case "object": // object 分为两种情况 对象（Object）或数组（Array）
              if (obj === null) {
                  o = null;
              } else {
                  if (Object.prototype.toString.call(obj).slice(8, -1) === "Array") {
                      o = [];
                      for (var i = 0; i < obj.length; i++) {
                          o.push(clone(obj[i]));
                      }
                  } else {
                      o = {};
                      for (var k in obj) {
                          o[k] = clone(obj[k]);
                      }
                  }
              }
              break;
          default:
              o = obj;
              break;
      }
      return o;
  }
  ```

5. 如何消除一个数组里面重复的元素
  ```JavaScript
  //方法一：
    var arr1 = [1,2,2,2,3,3,3,3,4,5,6],
        arr2 = [];
    for (var i = 0; i < arr1.length; i++) {
      if (arr2.indexOf(arr1[i]) < 0) {
        arr2.push(arr1[i]);
      }
    }
    document.write(arr2); //1,2,3,4,5,6
  ```

6. JavaScript代理
  当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。众所周知，DOM操作是十分消耗性能的。所以重复的事件绑定简直是性能杀手。而事件代理的核心思想，就是通过尽量少的绑定，去监听尽量多的事件。如何做呢?答案是利用事件冒泡机制,对其父节点ul进行事件绑定(Event Bubble),然后通过event.target来判断是哪个节点触发的事件，从而减少很多EventHandler的绑定。

7. 事件模型
    IE是冒泡从从叶子节点一层层向上冒到根节点
    捕获从根节点到叶子节点
    事件传送：1.事件捕获 2.查找到事件监听器后，执行 3.冒泡阶段
    attachEvent：冒泡，带有on
    addeventlistener：可选择捕获还是冒泡，不带有on

8. 如何实现一个对页面某个节点的拖拽(使用原生JS)
    [一步一步实现JS拖拽插件](http://www.cnblogs.com/lrzw32/p/4696655.html)

9. jQuery事件绑定区别on()、bind()与delegate() 方法详解
http://www.jb51.net/article/67166.htm

###腾讯面试题
1. 求输出
  ```JavaScript
    function fn() {
      this.a = 0;
      this.b = function() {
        alert(this.a);
      }
    }
    fn.prototype = {
      b: function() {
          this.a = 20;
          alert(this.a);
      },
      c: function() {
          this.a = 30;
          alert(this.a);
      }
    }
    var myfn = new fn();
    myfn.b();
    myfn.c();
  ```
  输出：0，30
  即调用了fn().b, prototype的b没有被调用。考察原型链。

2. 
  ```JavaScript
  var s='abc12345';
  var num=parseInt(s);
  if(num == NaN) {
    alert('NaN');
  } else if(typeof num == 'number'){
    alert('number');
  } else if(num == 'abc'){
    alert('abc');
  } else {
    alert('str');
  }
  ```
  输出：number
  因为parseInt解析一个字符串返回整数，虽然这里返回的是NaN，但是类型还是整数

3. cookie中的domain、path、expires、secure是什么意思,怎么用?
  1. path(路径): 
    指定与cookie关联的WEB页。
    值可以是一个目录，或者是一个路径。
    如果http://www.china.com/test/index.html 建立了一个cookie，那么在http://www.china.com/test/目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个cookie。
    这就是说，在http://www.china.com/test/test2/test3 里的任何页面都可以访问http://www.china.com/test/index.html建立的cookie。
    但是，如果http://www.china.com/test/ 需要访问http://www.china.com/test/index.html设置的cookes，该怎么办？
    这时，我们要把cookies的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。
  2. Domain(域):
    指定关联的WEB服务器或域。
    值是域名，比如www.china.com。这是对path路径属性的一个延伸。如果我们想让 www.china.com能够访问bbs.china.com设置的cookies，该怎么办? 我们可以把domain属性设置成“china.com”，并把path属性设置成“/”。
  3. Secure(安全):
    指定cookie的值通过网络如何在用户和WEB服务器之间传递。
    这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。
  4. Expires(过期时间):
    指cookie的生命期，确切地说是过期日期。
    如果想让cookie的存在期限超过当前浏览器的会话时间，就必须使用这个属性。当过了到期日期时，浏览器会自动删除cookie文件。

4. JS中的children和childNodes的区别
  答：Node(节点)是DOM层次结构中的任何类型的对象的通用名称，Node有很多类型，如元素节点，属性节点，文本节点，注释节点等，通过NodeType区分。
  Element继承了Node类，也就是说Element是Node多种类型中的一种，即当NodeType为1时Node即为ElementNode，另外Element扩展了Node，Element拥有id、class、children等属性。
  而children就是element的属性，得到的是element
  childNodes是node的属性，得到的是node(包含element)

5. 用JS实现div元素倒序排列(灵活使用getElement和Child操作)
  ```JavaScript
  var obj = document.getElementById("header").getElementsByTagName("div");
  var arr = [];
  for (var i = obj.length - 1; i >= 0; i--) {
    arr.push(obj[i]);
    document.getElementById("header").removeChild(obj[i]);
  }
  for (var i = 0; i < arr.length; i++) {
    document.getElementById("header").appendChild(arr[i]);
  }
  console.log(arr);
  ```

6. 

###HTTP
1. HTTP状态码500、404、400、304、302、301、200都表示什么意思
  1. 500：内部服务器错误
  2. 404：无法找到文件
  3. 400：请求无效
  4. 304：未修改，表示缓存是最新的，不更新，不返回网页的内容
  5. 302：临时重定向，请求的网页被临时移动到其他位置，但请求者依然会向原有的地址进行请求。
  6. 301：永久移动，请求的网页已经被移动到新的位置，但请求者会跳转到新的地址。
  7. 200：访问成功

2. 谈一谈Ajax的原理和处理机制
  
3. 谈一下你对网页性能优化的方法(摘自3)
  (1) 文件合并(减少HTTP请求数量)
    CSS Sprites
     　  利用css sprites将网站用到的图片合并成一张图片，通过background-position、width、height控制背景图位置来使用某一个图标，这种方式可以将多个图片请求缩减为一次
    合并js和CSS文件
     　  将所有CSS文件合并成一个文件，并没有什么争议，但是对于JS来说，现在模块化盛行，合并不一定正确。(作者vicfeel说，正确的方式是遵守编译型语言的模式，保持js的模块化，在生成过程中只对初始请求用到的js文件生成目标文件。)
  (2) 使用内容发布网络(减少HTTP请求时间)CDN
    　  HTTP请求时间另一个影响因素是你与网站web服务器所处的距离，显然距离越远，请求所需的时间也越久，通过CDN可以大大改善这一点。
    　 CDN是分布在多个不同地理位置的web服务器，用于更加有效的向用户发布内容。CDN最主要的功能是给终端用户存放静态文件，另外也提供下载、安全服务等功能。
  (3) 设置浏览器缓存(避免重复HTTP请求)
    使用Expire/Cache-control
      在支持HTTP1.1的情况下，要注意的一点：Cache-Control和Expire同时存在时，Cache-Control具有更高的优先级。
    配置或移除ETag
      ETag(Entity Tags)是在HTTP 1.1引入的，与Last-Modified同时存在时要有更高的优先级。
  (4) 压缩组件(减小HTTP请求大小)
    　  通过对HTTP传输的文件进行压缩减小HTTP请求的大小，提高请求速度，GZIP是目前最常用也是最有效的压缩方式。
  	　  然而，并非所有的资源文件都需要压缩，压缩的成本包括服务端需要花费CPU周期进行压缩，而客户端也需要对压缩文件进行解压缩，必须结合自己网站进行权衡。现在绝大多数网站都对其HTML文档进行压缩，部分网站选择对js、css进行压缩，几乎没有网站对图片、PDF等文件进行GZIP压缩，原因在于这些文件是已经被压缩过的，采用HTTP压缩已经被过压缩的东西并不能使它更小。事实上，添加标头，压缩字典，并校验响应体实际上使它变得更大，而且还浪费了CPU。
		　  如何对网站开启GZIP，需要在所使用的web服务器(IIS、Nginx、Apache等)中进行设置。
	(5) CSS文件放在首部
		　  将CSS文件放在首部和放在尾部，并不影响HTTP请求，因此从请求时间上来讲是一致的，然而从用户体验的角度，将CSS文件放在首部，会获得更好的用户体验。
		  原因在于浏览器是从上到下依次解析html文档，将CSS文件置于头部，页面会首先对CSS文件发出请求，随后加载DOM树并对其进行渲染，页面会逐步呈现在用户面前。
		　  而与之相反，如果将CSS文件放置在尾部，页面加载完整DOM之后请求CSS文件，然后对整个DOM树渲染并呈现给用户，从用户的角度，在css文件没有请求完成之前，整个页面是出于白屏状态的，白屏是浏览器的一种行为，David Hyatt对其的解释是这样的
		　　在样式树没有完全加载之前，渲染dom树就是一种浪费，因为在样式树加载完成之后会再次渲染，出现FOUC(无样式内容闪烁)问题。
		　  **另外要注意的一点** ，使用link而不是@import引入css样式表，使用@import引入的样式即使写在首部，也会在文档最后加载。
	(6)  JS文件放在尾部
		　  HTTP请求是并行的，不同浏览器并行下载的数目也不一样(2、4、或者8个)，并行下载提高了HTTP请求的速度。而将JS文件放在首部，不仅会阻塞后面文件的下载而且会阻塞页面的渲染。
		　  为什么会这样呢?原因有两个：
		　　JS文件中可能存在document.write修改页面的内容，因此页面会在脚本执行完成之后才可使渲染。
		　　不同JS文件不管大小如何，可能存在依赖关系，因此必须按照顺序进行执行，因此在加载脚本的时候并行下载是禁止的。
		　  所以，最好的方式是讲js文件放置在尾部，等页面所有可视化组件加载完成之后再进行请求，提高用户体验。
	(7) 避免CSS表达式
	CSS表达式是动态设置CSS属性的一种强大并且危险的方式，它受到了IE5以及之后版本、IE8之前版本的支持。
	(8) 精简JavaScript
		精简
		精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符（空格，换行、制表符），这样整个文件的大小就变小了。
		混淆
		混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程的难度，这也同时提高了性能。
		缺点：
		混淆本身比较复杂，可能会引入错误。
		需要对不能改变的符号做标记，防止JavaScript符号（譬如关键字、保留字）被修改。
		混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。
		在以上提到了关于用gzip之类的压缩方式来压缩文件，这边说明一下，就算使用gzip等方式来压缩文件，精简代码依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的获得更多的节省。
	(9) CSS的精简
		CSS的精简带来的节省一般来说是小于JavaScript精简的，因为CSS中注释和空白相对较少。
		除了移除空白、注释之外，CSS可以通过优化来获得更多的节省：
		合并相同的类；
		移除不使用的类；
	(10)[Web前端性能优化](http://blog.csdn.net/biyukai88/article/details/52601734)

###基础
1. 软件开发流程：问题的定义及规划 ——> 需求分析 ——> 软件设计 ——> 程序编码 ——> 软件测试 ——> 运行维护


最新笔试集锦：http://web.jobbole.com/88041/

摘自：
1. [2016年Web前端面试题目汇总 作者:_燎原之火](http://www.cnblogs.com/bigboyLin/p/5272902.html)
2. [腾讯前端面试题整理](http://www.zhufengpeixun.cn/JavaScriptmianshiti/2014-02-26/252.html)
3. [关于Cookie中的path、domain、expire、secure属性详述](http://blog.csdn.net/milkiroom/article/details/50538649)
4. [前端面试题及答案整理（一）, 作者: vicfeel](http://www.cnblogs.com/vicfeel/p/5702815.html)
